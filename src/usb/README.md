<!-- 
Documentation for EmbeddedComm project.

Copyright (C) 2025 Mateusz BogusÅ‚awski, E: mateusz.boguslawski@ibnet.pl
Partly generated by Gemini3
-->

# Linux Master & Pico Slave USB Implementation

This module provides the hardware-specific implementation of the EmbeddedComm protocol using the USB interface.

# Table of contents
1. [Main documentation](../../README.md)
1. [linuxMasterUSB](#linuxmasterusb-class)
1. [picoSlaveUSB](#picoslaveusb-class)

# linuxMasterUSB class
**Parent:** `GenericMaster<slaveInfo>`

Implements the master-side driver for Linux systems using the `libusb-1.0` library. It manages bulk transfers to specific USB endpoints.

### Slave Identification (`slaveInfo`)
Instead of a single integer address, this class uses a structure to identify slaves on the bus:
```cpp
struct slaveInfo {
    uint16_t PID; // Product ID
    uint16_t VID; // Vendor ID
};
```

### Constructor
```cpp
linuxMasterUSB();
```
Initializes the `libusb` context. Devices are opened dynamically when `readBytes` or `writeBytes` is called for a specific VID/PID pair.

### Dependencies
* **Library:** `libusb-1.0` **Package:** `libusb-1.0-0-dev` (Ubuntu/Debian)

### Usage
- [linuxMasterUSB example](../../examples/linuxMasterUSB/linuxMasterUSB.cpp)

---

# picoSlaveUSB class
**Parent:** `GenericSlave`

Implements the slave-side driver for the Raspberry Pi Pico (RP2040/RP2350) using the TinyUSB stack (Vendor Device Class).

### Singleton Pattern
This class is implemented as a strict singleton to ensure exclusive access to the USB hardware.
* **Instance:** Use pointer to global object returned by `picoSlaveUSB::get()`.
* **Restriction:** You cannot create new instances of `picoSlaveUSB`.

### Initialization
```cpp
void initialize(
    uint8_t *memory, 
    uint32_t memorySize
);
```
* **memory**: Pointer to the buffer serving as the slave's memory map.
* **memorySize**: Size of the memory buffer.
* **Note:** This method calls `board_init()` and `tusb_init()` internally.

### Processing Loop
The USB stack requires frequent polling to handle events. You must call the process method in your main loop:
```cpp
USBSlave.process();
```
This handles `tud_task()` and manages the bulk IN/OUT data transfers.

### Important: Disable USB Output
Since this class takes full control of the USB hardware for the Vendor Device Class, you **must not** enable standard USB stdio (Serial over USB) in your CMake configuration, as it will conflict with the driver or simply not function.

**In your `CMakeLists.txt`:**
```cmake
# Disable USB output
pico_enable_stdio_usb(picoSlaveUSB 0)

# If needed, enable UART output for debug logging
pico_enable_stdio_uart(picoSlaveUSB 1)
```

### Configuration

#### USB Descriptors
The device identity is defined in `usb_descriptors.c` (or via preprocessor definitions).
* **Endpoints:** Uses Endpoint 1 for Bulk OUT (`0x01`) and Bulk IN (`0x81`).
* **Packet Size:** 64 bytes (Full Speed).

#### Customizing
Change below lines in CMakeLists.txt to customize usb descriptors.
```
# Change below values to customize usb descriptors
target_compile_definitions(picoSlaveUSB PRIVATE
    USB_DEVICE_VID=0x1234
    USB_DEVICE_PID=0x1234
	USB_MANUFACTURER  "mboguslawski"
	USB_PRODUCT "EmmbeddedComm USB example"
	USB_SERIAL "000"
)
```

### Dependencies
* **SDK:** `pico-sdk`
* **Library:** `tinyusb_device`
* **CMake:** Ensure `tinyusb_dev` and `tinyusb_board` are linked.

---

### Usage
- [picoSlaveUSB example](../../examples/picoSlaveUSB/picoSlaveUSB.cpp)
